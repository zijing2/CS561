/*
 * File - sdap.pgc (Need the .pgc extension!) 
 *
 * Desc - This is a simple skeleton program using Embedded SQL to read all
 *        of the rows from the table "sales" and output to the console.
 *        Simple but it contains all of the essential features of ESQL 
 *        discussed in class!
 *
 * Steps to run this program : 
 *  1. In the program (L49), modify [dbname], [username], [password] to
 *     yours ([dbname] is the same as your [username] by default).
 *  2. Preprocessor - $ ecpg -I "C:\Program Files\PostgreSQL\9.4\include" sdap.pgc
 *  3. Compile      - $ gcc -c -I "C:\Program Files\PostgreSQL\9.4\include" sdap.c
 *  4. Link         - $ gcc -L "C:\Program Files\PostgreSQL\9.4\lib" -lecpg -o sdap sdap.o
 *  5. Execute      - $ .\sdap
 */

#include	<stdio.h>

//----------------------------------------------------------------------
// HOST VARIABLES definitions
//----------------------------------------------------------------------
EXEC SQL BEGIN DECLARE SECTION;

typedef struct {
	char	*cust;
	char	*prod;
	short    dd;
	short    mm;
	short	   yy;
	char	*state;
	long	 quant;
}	prod;

typedef struct {
   char *prod;
   int  total;
   int  count;
}  avg;

prod sale_rec;
prod max_quant_prod;
prod min_quant_prod;
prod ct_prod;
prod ny_prod;
prod nj_prod;
prod max_product_str[500];
prod min_product_str[500];
avg avg_product[500];
prod max_ct_prod_cust[500];
prod min_ny_prod_cust[500];
prod min_nj_prod_cust[500];


EXEC SQL END DECLARE SECTION;
EXEC SQL INCLUDE sqlca;

//----------------------------------------------------------------------
// FUNCTION PROTOTYPE declaration
//----------------------------------------------------------------------
void	output_record(); //output records to the console


//----------------------------------------------------------------------
int main(int argc, char* argv[])
//----------------------------------------------------------------------
{

   //----------------------------------------------------------------------
   // DATABASE CONNECTION
   //----------------------------------------------------------------------
   // EXEC SQL CONNECT TO PostgreSQL@localhost:5432 USER PostgreSQL IDENTIFIED BY XYZ;
   EXEC SQL CONNECT TO huangzijing@localhost:5432 USER huangzijing;
   
   if (sqlca.sqlcode != 0) {	// login error
   	printf ("Login error!!!\n");
   	return -1;
   }
   EXEC SQL WHENEVER sqlerror sqlprint;

   //----------------------------------------------------------------------
   // PRINT TITLE
   //----------------------------------------------------------------------   
   printf(" Product  MAX_Q CUSTOMER   DATE       ST MIN_Q CUSTOMER   DATE       ST AVE_Q \n");
   printf(" ======== ===== ========== ========== == ===== ========== ========== == ===== \n");
   
   //----------------------------------------------------------------------
   // READ RECORDS
   //----------------------------------------------------------------------
   EXEC SQL DECLARE mycursor CURSOR FOR SELECT * FROM sales;
   EXEC SQL SET TRANSACTION read only;
   // Open cursor
   EXEC SQL OPEN mycursor;
   // Fetch Data
   EXEC SQL FETCH FROM mycursor INTO :sale_rec; //fetch the first row

   while (sqlca.sqlcode == 0) {
      
      //max quant for each prod
      for(int i=0;i<50;i++){
         if(max_product_str[i].prod<=0){
            max_product_str[i] = sale_rec;         
            break;
         }else if(strcmp(max_product_str[i].prod,sale_rec.prod)==0){
            if(sale_rec.quant>max_product_str[i].quant){
               max_product_str[i] = sale_rec;
            }
            break;
         }
      }

      //min quant for each prod
      for(int i=0;i<50;i++){
         if(min_product_str[i].prod<=0){
            min_product_str[i] = sale_rec;         
            break;
         }else if(strcmp(min_product_str[i].prod,sale_rec.prod)==0){
            if(sale_rec.quant<min_product_str[i].quant){
               min_product_str[i] = sale_rec;
            }
            break;
         }
      }

      //avg quant for each prod
      for(int i=0;i<50;i++){
         if(avg_product[i].total<=0){
            avg_product[i].prod = sale_rec.prod;
            avg_product[i].total = sale_rec.quant;  
            avg_product[i].count = 1;       
            break;
         }else if(strcmp(avg_product[i].prod,sale_rec.prod)==0){
            avg_product[i].total = avg_product[i].total+sale_rec.quant;
            avg_product[i].count = avg_product[i].count+1;
            break;
         }
      }

      //max quant of CT for each prod and customer combine
      if(sale_rec.yy>=2000 && sale_rec.yy<=2005){
         for(int i=0;i<50;i++){
           if(max_ct_prod_cust[i].prod<=0){
               max_ct_prod_cust[i] = sale_rec;         
               break;
            }else if(strcmp(max_ct_prod_cust[i].prod,sale_rec.prod)==0 && strcmp(max_ct_prod_cust[i].cust,sale_rec.cust)==0){
               if(sale_rec.quant>max_ct_prod_cust[i].quant){
                  min_product_str[i] = sale_rec;
               }
               break;
            }
         }
      }
      
      //min quant of NY for each prod and customer combine
      for(int i=0;i<50;i++){
        if(min_ny_prod_cust[i].prod<=0){
            min_ny_prod_cust[i] = sale_rec;         
            break;
         }else if(strcmp(min_ny_prod_cust[i].prod,sale_rec.prod)==0 && strcmp(min_ny_prod_cust[i].cust,sale_rec.cust)==0){
            if(sale_rec.quant<min_ny_prod_cust[i].quant){
               min_ny_prod_cust[i] = sale_rec;
            }
            break;
         }
      }

      //min quant of NJ for each prod and customer combine
      for(int i=0;i<50;i++){
        if(min_nj_prod_cust[i].prod<=0){
            min_nj_prod_cust[i] = sale_rec;         
            break;
         }else if(strcmp(min_nj_prod_cust[i].prod,sale_rec.prod)==0 && strcmp(min_nj_prod_cust[i].cust,sale_rec.cust)==0){
            if(sale_rec.quant<min_nj_prod_cust[i].quant){
               min_nj_prod_cust[i] = sale_rec;
            }
            break;
         }
      }

      //free the char pointer in the struct
      sale_rec.cust = 0;
      sale_rec.prod = 0;
      sale_rec.state = 0;
                    
      EXEC SQL FETCH FROM mycursor INTO :sale_rec; //fetch the rest rows
   }

   for(int i=0;i<50;i++){

      if(max_product_str[i].prod>0){
         printf(" %-7s ",max_product_str[i].prod);   // Product
         printf(" %5ld",max_product_str[i].quant);  // Quantity
         printf(" %-5s   ",max_product_str[i].cust);   // Customer
         printf("   %02d/",max_product_str[i].mm);     // Month
         printf("%02d/",max_product_str[i].dd);     // Day
         printf("%4d ",max_product_str[i].yy);      // Year
         printf("%-2s ",max_product_str[i].state);  // State
         printf("%5ld",min_product_str[i].quant);  // Quantity
         printf(" %-5s   ",min_product_str[i].cust);   // Customer
         printf("   %02d/",min_product_str[i].mm);     // Month
         printf("%02d/",min_product_str[i].dd);     // Day
         printf("%4d ",min_product_str[i].yy);      // Year
         printf("%-2s ",min_product_str[i].state);  // State
         printf(" %5d \n",avg_product[i].total/avg_product[i].count);  // avg
      }
   
   }

   //for(int i=0;i<50;i++){
   //   if(avg_product[i].count>0){
   //      printf(" %-7s ",avg_product[i].prod);   // Product
   //      printf(" %5d",avg_product[i].total);  // Quantity
   //      printf(" %5d \n",avg_product[i].count);   // Customer
   //   }      
   //}

    //----------------------------------------------------------------------
   // PRINT TITLE
   //----------------------------------------------------------------------  
   printf("\n"); 
   printf(" CUSTOMER PRODUCT CT_MAX DATE       NY_MIN DATE       NJ_MIN DATE      \n");
   printf(" ======== ======= ====== ========== ====== ========== ====== ========= \n");

   for(int i=0;i<50;i++){
      if(max_ct_prod_cust[i].prod>0){
         printf(" %-5s   ",max_ct_prod_cust[i].cust);   // Customer
         printf(" %-7s",max_ct_prod_cust[i].prod);   // Product
         printf("  %5ld",max_ct_prod_cust[i].quant);      //max ct quant
         printf(" %02d/",max_ct_prod_cust[i].mm);     // Month
         printf("%02d/",max_ct_prod_cust[i].dd);     // Day
         printf("%4d ",max_ct_prod_cust[i].yy);      // Year
         printf(" %5ld",min_ny_prod_cust[i].quant);      //min ny quant
         printf(" %02d/",min_ny_prod_cust[i].mm);     // Month
         printf("%02d/",min_ny_prod_cust[i].dd);     // Day
         printf("%4d ",min_ny_prod_cust[i].yy);      // Year
         printf(" %5ld",min_nj_prod_cust[i].quant);      //min ny quant
         printf(" %02d/",min_nj_prod_cust[i].mm);     // Month
         printf("%02d/",min_nj_prod_cust[i].dd);     // Day
         printf("%4d \n",min_nj_prod_cust[i].yy);      // Year
         
      }
   }
      
   // Close cursor
   EXEC SQL CLOSE mycursor;

   return 0;
}



